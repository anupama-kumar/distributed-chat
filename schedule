Date Modified: 03/21/2016


--------------Schedule---------------
Finish me by March 28th

Contact TA to setup meeting by April 2nd

Finish Milestone 2 by April 11th
	--Handle addition and deletion of members
	--Send and receive messages across members
	--Ideally the core system functionality should be finished by now

Finish Final Milestone by April 24th
	--Implement extra credits (TBD)

Final demo on April 25th



-----Protocals-----
Message protocal: RPC on top of UDP

Message type: char ** sender_name, char ** message_body, char *** timestamps
	(Time stamps are char *, and array of timestamps is a char **, and since RPC requires pointers to these structures the final type being passed is a char ***)

Vector time stamps: These functions both for ordering messages and to recognize lost messages. For the lost messages, if the timestamp vector indicates that some messages have been delivered in between the client's last printed message and the one being currently recieved then it will hold back printing the incoming message for a perioud of time while it receievd the delayed intermediate messages. If after a waiting period the client has not received these missing messages then it broadcasts a request to all other clients to send the missing intervening messages. 

Leader Election Protocal: All clients are broadcasting an 'I am alive' message to other clients. This means that all clients ar eexpecting periodic 'I am alive' messages from one another.
	These messages at minimum consist of their name (char **) and may contain time stamp information. Each client has a thread running which is aware of the time, and both sends outgoing broadcasts and receives incomming messages of this type. When a client X misses enough check-ins from another client Y, then X assumes that Y has died (or potentially send a request for information to Y as a final attempt). If Y was the leader then X broadcasts a 'hold election' message. If Y is not in fact dead it will reply to the election message and the election will be cancelled. Otherwise the election process is an implementation of the bully algorithm where IDs are assigned based on when the client joined the chat. This will cause the oldest surviving chat member to be elected the leader, and naturally the initial state is that the client which created the chat is the leader.




Name states and write out process flow chart



// This is my version of the prtocol design and handling of failure

Unreliable chat	
Multicast Protocol design :
Main thread forks and executes RPC registration which will listen for incoming client requests in the background all the time. ( Assign leader here )
RPC is only invoked by clients on the IP address and port number of leader. There has to be a list of chat participants maintained by leader .
Client has 3 threads: 
- init data structures / listen to user input 
- listen for incoming UDP socket connections from leader / handle new messages/ request undelivered messages  
- check if leader is still alive
 
LEADER:
ordering incoming messages from each client - send/multicast it
maintain a buffer of recent messages in case of retransmission - sequence number
detect crash/ exiting users

CLIENT :
display messages relayed from leader in order ( total ordering ) according to the sequence number in the message
maintain list of other chat participants

A QUEUE thread
Calls RPC at regular intervals to make sure that leader is still alive 
Inform leader that its still alive
Call an election 

HANDLING FAILURE 
Leader dead / temp connection issue  Clients retry contacting leader ( say 5 times ) . In case of temp failure, leader has to somehow re-assert itself? More discussion needed.
Client dead / temp connection issue
	leader assumes client is dead and multicasts it but finally client rejoins chat .
