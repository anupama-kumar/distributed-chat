Date Modified: 03/27/2016

#Milestone 1 Schedule Document
* Spencer Caplan
* Jordan Kodner
* Anupama Kumar

##Schedule
1. Finish me by March 28th
2. Contact TA to setup meeting by April 2nd
3. Finish Milestone 2 by April 11th
..* Handle addition and deletion of members
..* Send and receive messages across members
..* Ideally the core system functionality should be finished by now
4. Finish Final Milestone by April 24th
..* Implement extra credits (TBD)
5. Final demo on April 25th

##Protocols

###General Information

####Networking Protocol
* UDP
* multicasted 

####General Message format

Message packets will be no larger than 1K. This means that larger messages may need to be reconstituted from several packets. We expect that this should be rare. Most should be under 1K in a text-only messaging client.

Messages components will be newline delimited. This is safe given user input from the commandline

<sender>\n<uid>\n<message type>\n<packet #>\n<total # packets expected>\n<message body>

1. <sender>: who sent this message
..* helpful in a multicast environment
2. <uid>: unique identifier
..* useful for message ordering
..* includes a sequence number and timestamp
3. <message type>: type of message this is
..* chat message
..* checkup message
..* election message
4. <packet #> This packet's ordering number within the message
..* important for reordering if messages received out of order
..* usually 0 because most messages should be short
5. <total # packets expected> How many packets are expected for this message
..* generally 1, but could be larger for larger messages
6. <message body>: any additional message contents

###Chat Messaging Protocol

This section defines how chat messages are sent. 

Messages will be multicast via UDP using the protocol defined above. 

Specifically,
1. <sender>: who sent this message
..* helpful in a multicast environment
2. <uid>: unique identifier
..* including a timestamp; set by sender
3. <message type>: CHAT
4. <packet #>
..* Can vary for larger chat messages
5. <total # packets expected> How many packets are expected for this message
..* generally 1 because most chat messages will be under our UDP packet limit
6. <message body> what the client wants to say.

Because we're using a central sequencer, we need an auxiliary message to help with ordering. Here's the idea.

A sender multicasts a message. Everyone (hopefully) receives it and adds it to a message queue. When the leader receives it, it assigns it a sequence number. It then broadcasts the follow message to indicate how everyone should order it. They then pull the appropriate message from their queue and display it.

1. <sender>: the leader
2. <uid>: unique identifier of original CHAT message
3. <message type>: SEQUENCE
4. <packet #>: 0
5. <total # packets expected>: 1
6. <message body>: sequence #

If a client finds that it's missing a message given the sequence numbers, it can request it from the leader by sending the leader a SEQUENCE message back. The leader will then send it the appropriate CHAT message

###Checkup Protocol

This section defines the bookkeeping process of checking who is still connected to chat. Chat clients should periodically multicast their existence. If a fixed number of these checkups are missed, the user is considered dead. If the leader is found to be dead, an election begins.

1. <sender>: client name
2. <uid>: associated IP address
3. <message type>: CHECKUP
4. <packet#>: 0
5. <total # packets>: 1
6. <message body>: empty

###Election Protocol

This section defines how leadership elections work in the likely event of our leader's untimely death. Once a client detects the death of a leader, it sends a start election message to everyone

1. <sender>: name
2. <uid>: IP
3. <mssage type>: ELECTION
4. <packet#>: 0
5. <total # packets>: 1
6. <message body>: none

Ranking is based on IP. Clients respond with vote messages containing an approve or reject. IPs lower than the candidate will reject.

1. <sender>: name
2. <uid>: IP
3. <mssage type>: VOTE
4. <packet#>: 0
5. <total # packets>: 1
6. <message body>: "approve" or "reject"

###Connection Protocol

This section defines how new clients are added to the chat.

A new client initially sends a join request message to any client. If that client is not a leader, it sends a leader info message back to the new client which then sends a join request to the leader.

Join Request
1. <sender>: new client name
2. <uid>: new client's IP
3. <mssage type>: JOIN_REQUEST
4. <packet#>: packet number
5. <total # packets>: number of packets in message
6. <message body>: a friendly user defined introduction message

Leader Info
1. <sender>: the client who received the join request
2. <uid>: the IP of that client
3. <message type>: LEADER_INFO
4. <packet#>: 0
5. <total # packets>: 1
6. <message body>: leader ip

When the leader receives a join request, it broadcasts a join message to all the clients including the new one to announce the new chat member. At this point, the clients can begin expecting checkups from the new member. Clients will print the original introduction message from the new client's join request

Join
1. <sender>: the leader
2. <uid>: the leader IP
3. <mssage type>: JOIN
4. <packet#>: packet number
5. <total # packets>: number of packets in message
6. <message body>: a friendly user defined welcome message and list of IPs of all the clients and a sequence number

The new client can start printing messages that are larger than the sequence number received. This sequence number is the number of the last message the leader sequenced before the new client joined.

If a client starts receiving checkups from a client it's never heard of before, it sends an inquiry to the leader by forwarding the checkup to the leader. If the leader hasn't heard of the client either, it doesn't respond. If it has heard of the client, it sends the inquiring client the JOIN message again.

##Leader Roles

###Sequencing



















old stuff below here
--------------------




Message protocal: RPC on top of UDP

Message type: char ** sender_name, char ** message_body, char *** timestamps
	(Time stamps are char *, and array of timestamps is a char **, and since RPC requires pointers to these structures the final type being passed is a char ***)

Vector time stamps: These functions both for ordering messages and to recognize lost messages. For the lost messages, if the timestamp vector indicates that some messages have been delivered in between the client's last printed message and the one being currently recieved then it will hold back printing the incoming message for a perioud of time while it receievd the delayed intermediate messages. If after a waiting period the client has not received these missing messages then it broadcasts a request to all other clients to send the missing intervening messages. 

Leader Election Protocal: All clients are broadcasting an 'I am alive' message to other clients. This means that all clients ar eexpecting periodic 'I am alive' messages from one another.
	These messages at minimum consist of their name (char **) and may contain time stamp information. Each client has a thread running which is aware of the time, and both sends outgoing broadcasts and receives incomming messages of this type. When a client X misses enough check-ins from another client Y, then X assumes that Y has died (or potentially send a request for information to Y as a final attempt). If Y was the leader then X broadcasts a 'hold election' message. If Y is not in fact dead it will reply to the election message and the election will be cancelled. Otherwise the election process is an implementation of the bully algorithm where IDs are assigned based on when the client joined the chat. This will cause the oldest surviving chat member to be elected the leader, and naturally the initial state is that the client which created the chat is the leader.




Name states and write out process flow chart
